<!DOCTYPE html>
<html lang="es">
<head>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <meta charset="UTF-8" />
  <title>LC-ADVANCE.GAME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, orientation=landscape" />
  <style>
    html, body {
      margin: 0;
      background: #000;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas#game {
      height: 100vh;
      aspect-ratio: 1 / 1;
      image-rendering: pixelated;
      border: 2px solid #fff;
      background: #838383;
    }
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

#pauseMenu {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #111;
  color: #0cc; /* azul m√°s tenue */
  padding: 30px;
  border: 3px solid #0cc;
  text-align: center;
  z-index: 1000;
  font-family: 'Press Start 2P', monospace;
  box-shadow: 0 0 10px #0cc; /* menos brillo */
}

#pauseMenu h2 {
  margin-bottom: 20px;
  text-shadow: 0 0 3px #0cc, 0 0 6px #0cc; /* menos capas */
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.menu-buttons button {
  padding: 12px;
  background: #222;
  color: #f0f;
  border: 2px solid #f0f;
  cursor: pointer;
  font-family: 'Press Start 2P', monospace;
  text-shadow: 0 0 3px #f0f; /* menos difuminado */
  box-shadow: 0 0 8px #f0f;  /* menos brillo */
  transition: transform 0.2s ease, box-shadow 0.3s ease;
}

.menu-buttons button:hover {
  transform: scale(1.05);
  box-shadow: 0 0 12px #ff0; /* brillo m√°s controlado */
  color: #ff0;
  border-color: #ff0;
  text-shadow: 0 0 4px #ff0;
}


    /* ORIENTACI√ìN HORIZONTAL OBLIGATORIA */
    @media screen and (orientation: portrait) {
      body::before {
        content: "üîÑ POR FAVOR, GIRA TU DISPOSITIVO PARA JUGAR (MODO HORIZONTAL)";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        color: #0cc;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 999999;
        text-align: center;
        padding: 20px;
        font-family: 'Press Start 2P', monospace;
        font-size: 16px;
        border: 4px solid #f0f;
      }
      #game, #mobileControls, #pauseMenu, #mensajeE {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  
  <div id="pauseMenu">
  <h2>‚è∏ Juego en Pausa</h2>
  <div class="menu-buttons">
    <!-- CONTINUAR -->
    <button onclick="document.getElementById('pauseMenu').style.display='none'">
      ‚ñ∂ CONTINUAR
    </button>

    <!-- REGRESAR AL MENU -->
    <button onclick="window.location.href='../index.php'">
      ‚òó REGRESAR AL MENU
    </button>
  </div>
</div>
<!-- Cuadro fijo en la esquina superior derecha -->
<div id="mensajeE"></div>

<style>
  #mensajeE {
    position: fixed;              /* siempre visible en pantalla */
    top: 20px;                    /* margen desde arriba */
    right: 20px;                  /* margen desde la derecha */
    background: rgba(0,0,0,0.7);  /* fondo oscuro semitransparente */
    color: white;                 /* texto blanco */
    padding: 10px 15px;           /* espacio interno */
    border-radius: 6px;           /* esquinas redondeadas */
    font-family: 'Press Start 2P', monospace; /* estilo retro 8-bit */
    font-size: 18px;
    z-index: 9999;                /* se superpone a todo */
    pointer-events: none;         /* evitar clicks por defecto */
  }

  /* prompt estilo app */
  .interaction-prompt {
    pointer-events: auto;
    display:flex;
    gap:10px;
    align-items:center;
    background: rgba(0,0,0,0.85);
    color:#fff;
    padding:8px 12px;
    border-radius:10px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  }
  .prompt-key {
    background: #00ffff;
    color:#000;
    font-weight:700;
    padding:6px 8px;
    border-radius:6px;
    font-family: 'Press Start 2P', monospace;
    font-size: 13px;
  }
  .prompt-text { font-size: 18px; }
  
  /* Controles m√≥viles */
  .mobile-controls {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 16px;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    padding: 0 16px;
    gap: 24px;
    z-index: 10000;
    pointer-events: auto;
    width: 100%;
  }
  .mobile-controls .dpad {
    display: grid;
    grid-template-columns: 48px 48px 48px;
    grid-template-rows: 48px 48px 48px;
    gap: 8px;
  }
  .mobile-controls .dpad .btn {
    display: inline-flex; align-items: center; justify-content: center;
    background: rgba(0,0,0,0.6);
    color: #0cc;
    border: 2px solid #0cc;
    border-radius: 10px;
    font-family: 'Press Start 2P', monospace;
    font-size: 16px;
    box-shadow: 0 0 10px rgba(0,204,204,0.6);
    user-select: none;
    touch-action: none;
  }
  .mobile-controls .actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .mobile-controls .actions .btn {
    min-width: 100px;
    padding: 12px 14px;
    background: rgba(0,0,0,0.7);
    color: #ff0;
    border: 2px solid #ff0;
    border-radius: 12px;
    font-family: 'Press Start 2P', monospace;
    font-size: 14px;
    box-shadow: 0 0 10px rgba(255,255,0,0.4);
    user-select: none;
    touch-action: none;
  }
  @media (min-width: 1025px) {
    .mobile-controls { display: none; }
  }

  /* Ajustes para orientaci√≥n vertical (portrait): botones m√°s grandes */
  @media (orientation: portrait) {
    .mobile-controls .dpad {
      grid-template-columns: 64px 64px 64px;
      grid-template-rows: 64px 64px 64px;
      gap: 10px;
    }
    .mobile-controls .dpad .btn { font-size: 20px; border-width: 3px; }
    .mobile-controls .actions .btn { min-width: 120px; font-size: 16px; padding: 14px 16px; }
    #mensajeE { font-size: 20px; }
    .prompt-text { font-size: 20px; }
  }

  html, body {
      margin: 0;
      background: #000;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    
    canvas#game {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      image-rendering: pixelated;
      border: 2px solid #fff;
      background: #838383;
      display: block;
    }

    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    #pauseMenu {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #111;
      color: #0cc;
      padding: 20px;
      border: 3px solid #0cc;
      text-align: center;
      z-index: 1000;
      font-family: 'Press Start 2P', monospace;
      box-shadow: 0 0 10px #0cc;
      max-width: 90vw;
      max-height: 90vh;
      overflow: auto;
    }

    #pauseMenu h2 {
      margin: 0 0 15px 0;
      font-size: clamp(16px, 4vw, 24px);
      text-shadow: 0 0 3px #0cc;
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .menu-buttons button {
      padding: 10px 15px;
      background: #222;
      color: #f0f;
      border: 2px solid #f0f;
      cursor: pointer;
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(10px, 2vw, 14px);
      text-shadow: 0 0 3px #f0f;
      box-shadow: 0 0 8px #f0f;
      transition: transform 0.2s ease, box-shadow 0.3s ease;
    }

    .menu-buttons button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 12px #ff0;
      color: #ff0;
      border-color: #ff0;
      text-shadow: 0 0 4px #ff0;
    }

    #mensajeE {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(10px, 1.5vw, 14px);
      z-index: 9999;
      pointer-events: none;
      max-width: 200px;
      word-wrap: break-word;
    }

    .interaction-prompt {
      pointer-events: auto;
      display: flex;
      gap: 8px;
      align-items: center;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 6px 10px;
      border-radius: 8px;
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 1.2vw, 12px);
      border: 1px solid #0cc;
      box-shadow: 0 0 8px rgba(0, 204, 204, 0.4);
    }

    .prompt-key {
      background: #00ffff;
      color: #000;
      font-weight: 700;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: clamp(8px, 1vw, 10px);
    }

    .prompt-text {
      font-size: clamp(9px, 1.2vw, 12px);
    }

    /* ===== CONTROLES M√ìVILES ===== */
    .mobile-controls {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 12px;
      gap: 16px;
      z-index: 10000;
      pointer-events: auto;
      width: 100%;
      box-sizing: border-box;
    }

    .mobile-controls .dpad {
      display: grid;
      grid-template-columns: 36px 36px 36px;
      grid-template-rows: 36px 36px 36px;
      gap: 6px;
    }

    .mobile-controls .dpad .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      color: #0cc;
      border: 2px solid #0cc;
      border-radius: 8px;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      box-shadow: 0 0 10px rgba(0, 204, 204, 0.6);
      user-select: none;
      touch-action: none;
      cursor: pointer;
      transition: all 0.2s;
      padding: 0;
      min-width: 36px;
      min-height: 36px;
    }

    .mobile-controls .dpad .btn:active {
      transform: scale(0.95);
      box-shadow: 0 0 5px rgba(0, 204, 204, 0.8);
    }

    .mobile-controls .actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .mobile-controls .actions .btn {
      min-width: 80px;
      padding: 8px 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #ff0;
      border: 2px solid #ff0;
      border-radius: 8px;
      font-family: 'Press Start 2P', monospace;
      font-size: clamp(9px, 1vw, 11px);
      box-shadow: 0 0 8px rgba(255, 255, 0, 0.4);
      user-select: none;
      touch-action: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mobile-controls .actions .btn:active {
      transform: scale(0.95);
      box-shadow: 0 0 12px rgba(255, 255, 0, 0.6);
    }

    /* Ocultar en desktop */
    @media (min-width: 1025px) {
      .mobile-controls {
        display: none;
      }
    }

    /* Landscape espec√≠fico */
    @media (orientation: landscape) {
      .mobile-controls .dpad {
        grid-template-columns: 32px 32px 32px;
        grid-template-rows: 32px 32px 32px;
        gap: 5px;
      }

      .mobile-controls .dpad .btn {
        min-width: 32px;
        min-height: 32px;
        font-size: 10px;
      }

      .mobile-controls .actions .btn {
        min-width: 70px;
        padding: 6px 8px;
        font-size: 8px;
      }
    }

    /* Portrait */
    @media (orientation: portrait) {
      .mobile-controls .dpad {
        grid-template-columns: 48px 48px 48px;
        grid-template-rows: 48px 48px 48px;
        gap: 8px;
      }

      .mobile-controls .dpad .btn {
        min-width: 48px;
        min-height: 48px;
        font-size: 16px;
        border-width: 2px;
      }

      .mobile-controls .actions .btn {
        min-width: 100px;
        padding: 10px 12px;
        font-size: 10px;
      }
    }
</style>
  <canvas id="game" width="512" height="512"></canvas>
  <!-- Controles m√≥viles -->
  <div class="mobile-controls" id="mobileControls">
    <div class="dpad">
      <div></div>
      <button class="btn" id="btnUp" aria-label="Arriba">‚ñ≤</button>
      <div></div>
      <button class="btn" id="btnLeft" aria-label="Izquierda">‚óÄ</button>
      <div></div>
      <button class="btn" id="btnRight" aria-label="Derecha">‚ñ∂</button>
      <div></div>
      <button class="btn" id="btnDown" aria-label="Abajo">‚ñº</button>
      <div></div>
    </div>
    <div class="actions">
      <button class="btn" id="btnInteract" aria-label="Hablar">HABLAR</button>
      <button class="btn" id="btnPause" aria-label="Pausa">PAUSA</button>
    </div>
  </div>

  <script type="module">
// √önica zona de estado global
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: false });

const world = {
  map: null,
  tilesets: [],
  cameraX: 0,
  cameraY: 0,
  player: { x: 0, y: 0, speed: 2, currentSprite: null }
};

// Teclado (declarado una sola vez)
const KEYS = new Set();
window.addEventListener("keydown", (e) => KEYS.add(e.key.toLowerCase()));
window.addEventListener("keyup", (e) => KEYS.delete(e.key.toLowerCase()));

// Controles m√≥viles: mapear a KEYS
function bindTouchButton(el, keyDown, keyUp, pulse=false) {
  if (!el) return;
  const addKey = () => { KEYS.add(keyDown); if (pulse) setTimeout(()=>KEYS.delete(keyDown), 120); };
  const removeKey = () => { KEYS.delete(keyDown); if (keyUp) KEYS.delete(keyUp); };
  const onStart = (ev) => { ev.preventDefault(); addKey(); };
  const onEnd = (ev) => { ev.preventDefault(); removeKey(); };
  el.addEventListener('touchstart', onStart, { passive: false });
  el.addEventListener('touchend', onEnd, { passive: false });
  el.addEventListener('mousedown', onStart);
  el.addEventListener('mouseup', onEnd);
  el.addEventListener('mouseleave', onEnd);
}

// Inicializar controles m√≥viles
(() => {
  const up = document.getElementById('btnUp');
  const down = document.getElementById('btnDown');
  const left = document.getElementById('btnLeft');
  const right = document.getElementById('btnRight');
  const interact = document.getElementById('btnInteract');
  const pause = document.getElementById('btnPause');
  bindTouchButton(up, 'arrowup');
  bindTouchButton(down, 'arrowdown');
  bindTouchButton(left, 'arrowleft');
  bindTouchButton(right, 'arrowright');
  bindTouchButton(interact, 'e', null, true);
  bindTouchButton(pause, 'escape', null, true);
})();

// Utilidades b√°sicas de colisi√≥n
function intersectsRect(a, b) {
  return !(a.x + a.width <= b.x ||
           a.x >= b.x + b.width ||
           a.y + a.height <= b.y ||
           a.y >= b.y + b.height);
}

// Pol√≠gonos: point-in-polygon + helpers
function pointInPolygon(x, y, points) {
  if (!Array.isArray(points) || points.length === 0) return false;
  let inside = false;
  for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
    const xi = points[i].x, yi = points[i].y;
    const xj = points[j].x, yj = points[j].y;
    const intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// Normalizar objetos Tiled (tile-objects, puntos, pol√≠gonos)
function normalizeObject(obj, map, tilesets) {
  if (!obj) return null;
  const copy = Object.assign({}, obj);
  // Mantener properties, name
  copy.properties = obj.properties || copy.properties;
  // Ajustar tile-objects (gid) porque Tiled pone y en base del tile
  if (copy.gid) {
    const info = getTileInfo(copy.gid, tilesets);
    const tileW = info?.ts?.tilewidth || map.tilewidth || 32;
    const tileH = info?.ts?.tileheight || map.tileheight || tileW;
    copy.y = (obj.y || 0) - tileH;
    copy.width = copy.width || tileW;
    copy.height = copy.height || tileH;
  } else {
    if (!copy.width && !copy.height) { copy.width = 8; copy.height = 8; }
  }
  if (Array.isArray(copy.polygon) && copy.polygon.length) {
    copy.points = copy.polygon.map(p => ({ x: (copy.x || 0) + p.x, y: (copy.y || 0) + p.y }));
  } else if (Array.isArray(copy.points) && copy.points.length) {
    copy.points = copy.points.map(p => ({ x: (copy.x || 0) + p.x, y: (copy.y || 0) + p.y }));
  }
  copy.x = copy.x || 0;
  copy.y = (typeof copy.y === 'number') ? copy.y : 0;
  return copy;
}

// Sprite jugador
const playerSprites = { left: new Image(), right: new Image(), up: new Image(), down: new Image() };
playerSprites.left.src = "./C_L.gif";
playerSprites.right.src = "./C_R.gif";
playerSprites.up.src = "./C_U.gif";
playerSprites.down.src = "./C_D.gif";
world.player.currentSprite = playerSprites.down;
const ZOOM = 1.5;
const DEBUG = false;

    async function loadJSON(path) {
      const res = await fetch(path, { cache: "no-store" });
      if (!res.ok) throw new Error("No se pudo cargar " + path);
      return await res.json();
    }
    async function loadText(path) {
      const res = await fetch(path, { cache: "no-store" });
      if (!res.ok) throw new Error("No se pudo cargar " + path);
      return await res.text();
    }
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error("No se pudo cargar imagen: " + src));
        img.src = src;
      });
    }

function resolveTileset(ts) {
  const source = ts.source;
  if (!source || source.startsWith(":/")) return null;

  const filename = source.split("/").pop();
  const tsxPath = `./tilesets/${filename}`;

  return loadText(tsxPath)
    .then(text => {
      const tileset = parseTSX(text, ts.firstgid);
      // Resuelve la imagen relativa al TSX usando una base absoluta correcta
      const baseUrl = new URL(tsxPath, window.location.href);
      if (!tileset.source) {
        console.warn('Tileset TSX sin <image source>:', tsxPath);
        return tileset;
      }
      tileset.image.src = new URL(tileset.source, baseUrl).href;
      return tileset;
    })
    .catch(err => {
      console.error(`‚ùå No se pudo cargar ${filename}`, err);
      return null;
    });
}

function parseTSX(text, firstgid) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(text, "application/xml");

  const tileset = xml.querySelector("tileset");
  const image = tileset.querySelector("image");

  const tilecount = parseInt(tileset.getAttribute("tilecount"));
  const columns = parseInt(tileset.getAttribute("columns"));
  const tilewidth = parseInt(tileset.getAttribute("tilewidth"));
  const tileheight = parseInt(tileset.getAttribute("tileheight"));
  const source = image.getAttribute("source");

  return {
    firstgid,
    lastgid: firstgid + tilecount - 1,
    tilecount,
    columns,
    tilewidth,
    tileheight,
    image: new Image(),
    source
  };
}


function cleanGID(gid) {
  const FLIP_MASK = 0xE0000000;
  return gid & ~FLIP_MASK;
}

function getTileInfo(gid, tilesets) {
  const rawGid = gid;
  gid = cleanGID(gid);
  if (!gid) return null;

  // Busca por firstgid/lastgid del mapa original
  let ts = null;
  for (let i = tilesets.length - 1; i >= 0; i--) {
    const t = tilesets[i];
    if (gid >= t.firstgid && gid <= t.lastgid) { ts = t; break; }
  }
  if (!ts) return null;

  const localId = gid - ts.firstgid;
  const sx = (localId % ts.columns) * ts.tilewidth;
  const sy = Math.floor(localId / ts.columns) * ts.tileheight;

  return { ts, sx, sy, rawGid };
}
function renderTileLayer(ctx, map, tilesets, layer, cameraX = 0, cameraY = 0) {
  const { tilewidth, tileheight } = map;
  if (!layer.chunks || !Array.isArray(layer.chunks)) return;

  for (const chunk of layer.chunks) {
    const { data, width, height, x: chunkX, y: chunkY } = chunk;
    const chunkPixelX = chunkX * tilewidth;
    const chunkPixelY = chunkY * tileheight;
    const chunkPixelW = width * tilewidth;
    const chunkPixelH = height * tileheight;

    // Culling de chunks
    if (chunkPixelX + chunkPixelW < cameraX || chunkPixelY + chunkPixelH < cameraY ||
        chunkPixelX > cameraX + canvas.width || chunkPixelY > cameraY + canvas.height) {
      continue;
    }

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let gid = data[y * width + x];
        if (!gid) continue;

        const info = getTileInfo(gid, tilesets);
        if (!info) continue;

        const dx = (chunkX + x) * tilewidth - cameraX;
        const dy = (chunkY + y) * tileheight - cameraY;

        // Culling por tile
        if (dx + tilewidth < 0 || dy + tileheight < 0 ||
            dx > canvas.width || dy > canvas.height) {
          continue;
        }

        // --- Flips y rotaciones de Tiled ---
        const FLIP_H = 0x80000000;
        const FLIP_V = 0x40000000;
        const FLIP_D = 0x20000000;

        const flipH = (info.rawGid & FLIP_H) !== 0;
        const flipV = (info.rawGid & FLIP_V) !== 0;
        const flipD = (info.rawGid & FLIP_D) !== 0;

        ctx.save();
        ctx.translate(dx + map.tilewidth / 2, dy + map.tileheight / 2);

        let scaleX = 1, scaleY = 1, rotate = 0;
        if (flipD) {
          rotate = Math.PI / 2;
          scaleX = flipV ? -1 : 1;
          scaleY = flipH ? -1 : 1;
        } else {
          scaleX = flipH ? -1 : 1;
          scaleY = flipV ? -1 : 1;
        }

        ctx.rotate(rotate);
        ctx.scale(scaleX, scaleY);

        ctx.drawImage(
          info.ts.image,
          info.sx, info.sy,
          info.ts.tilewidth, info.ts.tileheight,
          -map.tilewidth / 2, -map.tileheight / 2,
          map.tilewidth, map.tileheight
        );

        ctx.restore();
      }
    }
  }
}



    

function orient(a, b, c) {
  return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}
function onSegment(a, b, c) {
  return Math.min(a.x, b.x) <= c.x && c.x <= Math.max(a.x, b.x) &&
         Math.min(a.y, b.y) <= c.y && c.y <= Math.max(a.y, b.y);
}
function segIntersect(a, b, c, d) {
  const o1 = orient(a, b, c);
  const o2 = orient(a, b, d);
  const o3 = orient(c, d, a);
  const o4 = orient(c, d, b);
  if (o1 === 0 && onSegment(a, b, c)) return true;
  if (o2 === 0 && onSegment(a, b, d)) return true;
  if (o3 === 0 && onSegment(c, d, a)) return true;
  if (o4 === 0 && onSegment(c, d, b)) return true;
  return (o1 > 0) !== (o2 > 0) && (o3 > 0) !== (o4 > 0);
}

function intersectsPolygon(rect, polyOrObj) {
  const points = Array.isArray(polyOrObj) ? polyOrObj : (polyOrObj && polyOrObj.points) || polyOrObj && polyOrObj.polygon;
  if (!Array.isArray(points) || points.length === 0) return false;

  // 1) Si alg√∫n punto del pol√≠gono est√° dentro del rect√°ngulo
  for (const p of points) {
    if (p.x >= rect.x && p.x <= rect.x + rect.width && p.y >= rect.y && p.y <= rect.y + rect.height) {
      return true;
    }
  }

  // 2) Si alguna esquina del rect√°ngulo est√° dentro del pol√≠gono
  const corners = [
    { x: rect.x, y: rect.y },
    { x: rect.x + rect.width, y: rect.y },
    { x: rect.x, y: rect.y + rect.height },
    { x: rect.x + rect.width, y: rect.y + rect.height }
  ];
  if (corners.some(c => pointInPolygon(c.x, c.y, points))) return true;

  // 3) Si alguna arista del pol√≠gono intersecta alguna arista del rect√°ngulo
  const rectEdges = [
    [{ x: rect.x, y: rect.y }, { x: rect.x + rect.width, y: rect.y }],
    [{ x: rect.x + rect.width, y: rect.y }, { x: rect.x + rect.width, y: rect.y + rect.height }],
    [{ x: rect.x + rect.width, y: rect.y + rect.height }, { x: rect.x, y: rect.y + rect.height }],
    [{ x: rect.x, y: rect.y + rect.height }, { x: rect.x, y: rect.y }]
  ];

  for (let i = 0; i < points.length; i++) {
    const a = points[i];
    const b = points[(i + 1) % points.length];
    for (const [c, d] of rectEdges) {
      if (segIntersect(a, b, c, d)) return true;
    }
  }

  return false;
}


// A√±adir cat√°logo legacy (ids -> profesor) para compatibilidad con Mapa original
const zonasProfesores = {
    130: "Miguel",
    132: "Enrique",
    135: "Espindola",
    137: "Manuel",
    138: "Meza",
    140: "Herson",
    141: "Carolina",
    142: "Refugio & Padilla"
};

// Click directo en prompt tambi√©n ejecuta interacci√≥n
document.addEventListener('click', (ev) => {
  const target = ev.target.closest && ev.target.closest('.interaction-prompt');
  if (target) {
    const inter = world.interaccionActual || getInteraccionActual();
    if (inter) ejecutarInteraccion(inter);
  }
}, { passive: true });

/* ===== Interacci√≥n: utilidades y funciones √∫nicas (reemplazar duplicados existentes) ===== */
function getProp(obj, name) {
  if (!obj) return null;
  if (obj[name] !== undefined) return obj[name];
  const names = [name, name.toLowerCase(), 'profesor','Profesor','maestro','Maestro','nombreProfesor','nombre','teacher'];
  if (Array.isArray(obj.properties)) {
    for (const p of obj.properties) {
      if (names.includes(p.name) || names.includes(String(p.name))) return (p.value !== undefined ? p.value : p);
    }
  } else if (obj.properties && typeof obj.properties === 'object') {
    for (const n of names) {
      if (obj.properties[n] !== undefined) return obj.properties[n].value ?? obj.properties[n];
    }
  }
  return null;
}

// identificarProfesor ‚Äî implementaci√≥n unificada
function identificarProfesor(obj) {
  if (!obj) return null;
  // legacy id map
  if (typeof obj.id !== 'undefined' && zonasProfesores[obj.id]) return zonasProfesores[obj.id];

  const candidates = [
    obj.nombreProfesor,
    obj.profesor,
    getProp(obj, 'profesor'),
    getProp(obj, 'maestro'),
    getProp(obj, 'nombreProfesor'),
    obj.name
  ];

  for (const cand of candidates) {
    if (cand && String(cand).trim()) {
      const s = String(cand).trim();
      const m = s.match(/([A-Z√Å√â√ç√ì√ö√ë][a-z√°√©√≠√≥√∫√±]+(\s&\s?[A-Z√Å√â√ç√ì√ö√ëa-z√°√©√≠√≥√∫√±]+)?(\s[A-Z√Å√â√ç√ì√ö√ëa-z√°√©√≠√≥√∫√±]+)*)$/);
      return (m ? m[0] : s);
    }
  }
  return null;
}

/**
 * getInteraccionActual ‚Äî √∫nica funci√≥n: detecta interacciones (rect/pol√≠gono), devuelve
 * el objeto enriquecido con { nombreProfesor, materia } o null. Elige el m√°s cercano.
 */
function getInteraccionActual() {
  try {
    const foot = { x: world.player.x - 6, y: world.player.y + 6, width: 12, height: 12 };
    let best = null, bestDist2 = Infinity;
    const centroidOf = (o) => {
      if (Array.isArray(o.points) && o.points.length) {
        let sx = 0, sy = 0;
        for (const p of o.points) { sx += p.x; sy += p.y; }
        return { x: sx / o.points.length, y: sy / o.points.length };
      }
      return { x: (o.x || 0) + (o.width || 0)/2, y: (o.y || 0) + (o.height || 0)/2 };
    };

    for (const obj of (world.interacciones || [])) {
      if (!obj) continue;
      let intersects = false;
      if (Array.isArray(obj.points) && obj.points.length) {
        const corners = [
          { x: foot.x, y: foot.y },
          { x: foot.x + foot.width, y: foot.y },
          { x: foot.x, y: foot.y + foot.height },
          { x: foot.x + foot.width, y: foot.y + foot.height }
        ];
        if (corners.some(c => pointInPolygon(c.x, c.y, obj.points))) intersects = true;
      } else {
        const rect = { x: obj.x || 0, y: obj.y || 0, width: obj.width || 0, height: obj.height || 0 };
        if (intersectsRect(foot, rect)) intersects = true;
      }
      if (!intersects) continue;

      const c = centroidOf(obj);
      const dx = c.x - world.player.x, dy = c.y - world.player.y;
      const dist2 = dx*dx + dy*dy;
      if (dist2 < bestDist2) {
        bestDist2 = dist2;
        const nombreProfesor = identificarProfesor(obj) || null;
        const materia = getProp(obj, 'materia') || getProp(obj, 'asignatura') || null;
        best = Object.assign({}, obj, { nombreProfesor, materia });
      }
    }
    return best;
  } catch (err) {
    console.warn("getInteraccionActual fallo:", err);
    return null;
  }
}

// Escape para prompts (√∫nica implementaci√≥n)
function escapeHtml(s) {
  if (s === null || s === undefined) return '';
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]);
}

// Actualiza el prompt (sin bot√≥n) ‚Äî clic/tap y E llaman a la misma acci√≥n
function updateInteractionUI() {
  const el = document.getElementById('mensajeE');
  if (!el) return;
  const inter = world.interaccionActual || null;
  if (inter) {
    const nombre = inter.nombreProfesor || identificarProfesor(inter) || 'Profesor';
    const materia = inter.materia || getProp(inter, 'materia') || '';
    el.innerHTML = `
      <div class="interaction-prompt" role="status" aria-live="polite" data-materia="${escapeHtml(materia)}">
        <span class="prompt-key">E</span>
        <span class="prompt-text">Habla con <strong>${escapeHtml(nombre)}</strong>${materia ? ' ‚Äî ' + escapeHtml(materia) : ''}</span>
      </div>
    `;
  } else {
    el.innerHTML = '';
  }
}

// Click / touch en el prompt inicia la interacci√≥n
document.addEventListener('click', (ev) => {
  const target = ev.target.closest && ev.target.closest('.interaction-prompt');
  if (target) {
    const inter = world.interaccionActual || getInteraccionActual();
    if (inter) ejecutarInteraccion(inter);
  }
}, { passive: true });

// Ejecutar interacci√≥n: siempre env√≠a a updateDB y redirige (guarda posici√≥n antes)
function ejecutarInteraccion(obj) {
  if (!obj) return;
  const profesorRaw = obj.nombreProfesor || identificarProfesor(obj) || '';
  const profesor = String(profesorRaw).trim();
  let materia = obj.materia || getProp(obj, 'materia') || getProp(obj, 'asignatura') || null;
  if (materia) materia = String(materia).trim();

  console.debug("ejecutarInteraccion ->", { profesor, materia, obj });

  // Guardar posici√≥n para restaurar al volver al mapa
  if (typeof savePlayerPos === 'function') try { savePlayerPos(); } catch(e){}

  fetch('./updateDB.php', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ maestro: profesor || profesorRaw, materia: materia || null })
  })
  .then(res => res.json().then(j => console.debug('updateDB response', j)).catch(()=>{}))
  .catch(err => console.warn('updateDB failed:', err))
  .finally(() => {
    const param = materia ? `materia=${encodeURIComponent(materia)}` : `profesor=${encodeURIComponent(profesor || profesorRaw || '')}`;
    window.location.href = `../dashboard.php?${param}`;
  });
}


// --- loop: definida solo si no existe (evita duplicados) ---
if (typeof loop === 'undefined') {
  window.loop = function() {
    handleInput();
    render();
    requestAnimationFrame(loop);
  };
}

// --- Nuevo: funci√≥n de render principal (debe existir antes de iniciar el loop) ---
function render() {
  // limpiar y preparar
  ctx.save();
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // aplicar zoom
  ctx.save();
  ctx.scale(ZOOM, ZOOM);

  const map = world.map;
  if (map) {
    // Dibujar capas
    for (const layer of map.layers || []) {
      if (layer.type === "tilelayer") {
        renderTileLayer(ctx, map, world.tilesets, layer, world.cameraX, world.cameraY);
      }
    }
  }

  // === Dibujar jugador (siempre visible) ===
  try { drawPlayer(ctx); } catch (e) { console.warn("drawPlayer fallo:", e); }

  // Dibujar overlays de interacciones SOLO si estamos en modo DEBUG
  if (DEBUG) {
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = "#00ff66";
    ctx.lineWidth = 1;
    for (const obj of world.interacciones || []) {
      if (!obj) continue;
      if (obj.points && obj.points.length) {
        ctx.beginPath();
        ctx.moveTo(obj.points[0].x - world.cameraX, obj.points[0].y - world.cameraY);
        for (let i = 1; i < obj.points.length; i++) {
          ctx.lineTo(obj.points[i].x - world.cameraX, obj.points[i].y - world.cameraY);
        }
        ctx.closePath();
        ctx.stroke();
      } else {
        ctx.strokeRect(obj.x - world.cameraX, obj.y - world.cameraY, obj.width || 8, obj.height || 8);
      }
    }
    ctx.globalAlpha = 1;
  }

  ctx.restore(); // restore scale
  ctx.restore();
}

// DIBUJAR JUGADOR (centrado en c√°mara y compatible con ZOOM)
function drawPlayer(ctx) {
    const sprite = world.player.currentSprite;
    if (!sprite) return;
    // Coordenadas relativas a la c√°mara (ya dentro del contexto escalado)
    const px = world.player.x - world.cameraX - (sprite.width || 32) / 2;
    const py = world.player.y - world.cameraY - (sprite.height || 32) + 8; // ajustar pies
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(sprite, px, py, sprite.width || 32, sprite.height || 32);
}

// Comprueba si un rect se superpone con alguna interacci√≥n (pol√≠gono o rect)
function rectOverlapsAnyInteraction(rect) {
  for (const obj of (world.interacciones || [])) {
    if (!obj) continue;
    if (obj.points && obj.points.length) {
      if (intersectsPolygon(rect, obj)) return true;
      continue;
    }
    const ox = obj.x || 0, oy = obj.y || 0, ow = obj.width || 0, oh = obj.height || 0;
    if (!(rect.x + rect.width <= ox || rect.x >= ox + ow || rect.y + rect.height <= oy || rect.y >= oy + oh)) {
      return true;
    }
  }
  return false;
}

// `identificarProfesor` ya est√° definida arriba; usar esa √∫nica implementaci√≥n.

// `updateInteractionUI` ya est√° definida arriba; usar esa √∫nica implementaci√≥n.

// Manejo de entrada y movimiento del jugador
function handleInput() {
  try {
    let dx = 0, dy = 0;
    if (KEYS.has("arrowleft") || KEYS.has("a")) { dx -= world.player.speed; world.player.currentSprite = playerSprites.left; }
    if (KEYS.has("arrowright") || KEYS.has("d")) { dx += world.player.speed; world.player.currentSprite = playerSprites.right; }
    if (KEYS.has("arrowup") || KEYS.has("w")) { dy -= world.player.speed; world.player.currentSprite = playerSprites.up; }
    if (KEYS.has("arrowdown") || KEYS.has("s")) { dy += world.player.speed; world.player.currentSprite = playerSprites.down; }

    const nextRect = { x: world.player.x + dx, y: world.player.y + dy, width: 6, height: 6 };

    // Comprueba colisiones; si la colisi√≥n est√° solapada por una interacci√≥n la ignoramos para permitir entrar
    const blocked = (world.collisions || []).some(c => {
      if (c.type === 'rect') {
        if (intersectsRect(nextRect, c)) {
          return !rectOverlapsAnyInteraction(nextRect);
        }
      } else if (c.type === 'polygon') {
        if (intersectsPolygon(nextRect, c)) {
          return !rectOverlapsAnyInteraction(nextRect);
        }
      } else {
        if (intersectsRect(nextRect, c) || (c.points && c.points.length && intersectsPolygon(nextRect, c))) {
          return !rectOverlapsAnyInteraction(nextRect);
        }
      }
      return false;
    });

    if (!blocked) {
      world.player.x += dx;
      world.player.y += dy;
    }

    // Actualizar c√°mara
    world.cameraX = world.player.x - (canvas.width / (2 * ZOOM));
    world.cameraY = world.player.y - (canvas.height / (2 * ZOOM));

    // Actualizar interacci√≥n detectada y UI
    world.interaccionActual = getInteraccionActual();
    updateInteractionUI();

    // Interacci√≥n con tecla E
    if (KEYS.has("e")) {
      const interaccion = world.interaccionActual || getInteraccionActual();
      if (interaccion) {
        ejecutarInteraccion(interaccion);
      } else {
        const select = document.getElementById("materia-select");
        if (select && select.value) {
          window.location.href = `../dashboard.php?materia=${encodeURIComponent(select.value)}`;
        }
      }
      KEYS.delete("e");
    }

    // Pausa con ESC
    if (KEYS.has("escape")) {
      const pauseMenu = document.getElementById("pauseMenu");
      if (pauseMenu) pauseMenu.style.display = (pauseMenu.style.display === "block") ? "none" : "block";
      KEYS.delete("escape");
    }

  } catch (err) {
    console.warn('handleInput fallo:', err);
  }
}

// Guardar / restaurar posici√≥n del jugador para volver EXACTO al punto anterior
function savePlayerPos() {
    try {
        const pos = { x: world.player.x, y: world.player.y };
        localStorage.setItem('map.player_pos', JSON.stringify(pos));
        console.debug('map: saved player pos', pos);
    } catch(e) { console.warn('savePlayerPos fallo', e); }
}

function loadPlayerPos() {
    try {
        const raw = localStorage.getItem('map.player_pos');
        if (!raw) return null;
        const p = JSON.parse(raw);
        if (typeof p.x === 'number' && typeof p.y === 'number') {
            console.debug('map: restoring player pos', p);
            return p;
        }
    } catch(e) { console.warn('loadPlayerPos fallo', e); }
    return null;
}

// Llamar a savePlayerPos antes de redirigir/interactuar y en beforeunload
window.addEventListener('beforeunload', savePlayerPos, { passive: true });

// Dentro de init(), despu√©s de calcular spawn fallback, intentar restaurar posici√≥n:
async function init() {
  try {
    // Intentar varios nombres de archivo para compatibilidad
    const candidates = ["./Mapa.json","./Mapa-corregido.json","./Mapa..json","./Map.json"];
    let map = null;
    for (const p of candidates) {
      try { map = await loadJSON(p); if (map) { console.log('Mapa cargado:', p); break; } } catch(e) { /* ignore */ }
    }
    if (!map) throw new Error('No se pudo encontrar ning√∫n Mapa JSON (probados: ' + candidates.join(', ') + ')');

    // Cargar y resolver tilesets (omitir los internos de Tiled)
    let tilesets = await Promise.all(
      (map.tilesets || []).filter(ts => ts.source && !ts.source.startsWith(':/')).map(ts => resolveTileset(ts))
    );
    tilesets = tilesets.filter(Boolean).sort((a,b)=>a.firstgid-b.firstgid);

    world.map = map;
    world.tilesets = tilesets;

    // Posici√≥n inicial del jugador (primer chunk con offsets como en index_old)
    const firstLayer = map.layers.find(l => l.type === 'tilelayer' && l.chunks && l.chunks.length);
    if (firstLayer) {
      const firstChunk = firstLayer.chunks[0];
      const spawnOffsetY = 960;
      const spawnOffsetX = 490;
      const spawnX = (firstChunk.x + firstChunk.width / 2) * map.tilewidth + spawnOffsetX;
      const spawnY = (firstChunk.y + firstChunk.height / 2) * map.tileheight + spawnOffsetY;

      // Intentar restaurar posici√≥n guardada (si existe) -> si no, usar spawn
      const restored = loadPlayerPos();
      world.player.x = restored ? restored.x : spawnX;
      world.player.y = restored ? restored.y : spawnY;
    }

    // Cargar colisiones
    function loadCollisions(map) {
      const colLayer = map.layers.find(l => l.name === 'Coliciones' && l.type === 'objectgroup');
      if (!colLayer) return [];
      return colLayer.objects
        .filter(obj => obj.x !== undefined && obj.y !== undefined)
        .map(obj => {
          if (Array.isArray(obj.polygon) && obj.polygon.length > 0) {
            return { type: 'polygon', points: obj.polygon.map(p => ({ x: obj.x + p.x, y: obj.y + p.y - (obj.height || 0) })) };
          } else if (obj.width && obj.height) {
            return { type: 'rect', x: obj.x, y: obj.y, width: obj.width, height: obj.height };
          }
          return null;
        })
        .filter(Boolean);
    }

    world.collisions = loadCollisions(map);
    console.log('Colisiones cargadas:', world.collisions.length);

    // Interacciones: normalizar objetos para usar en detecci√≥n
    const interaccionesLayer = map.layers.find(l => l.name === 'Interacciones' && l.type === 'objectgroup');
    world.interacciones = interaccionesLayer ? interaccionesLayer.objects.map(o => normalizeObject(o, map, tilesets)) : [];
    console.log('Interacciones cargadas:', world.interacciones.length);

    // Ajustar c√°mara inicial
    world.cameraX = world.player.x - (canvas.width / (2 * ZOOM));
    world.cameraY = world.player.y - (canvas.height / (2 * ZOOM));

    // Arrancar el bucle
    loop();
  } catch (err) {
    console.error('Error en init:', err);
    ctx.fillStyle = '#ff3355';
    ctx.font = '16px monospace';
    ctx.fillText('Error al cargar mapa', 20, 20);
  }
}

init();
</script>
</body>
</html>
